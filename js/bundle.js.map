{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,IAAI,EAAC,CAAC;;;;;;;;;;;;;;;;ACjH4B,CAAC;;AAElD;AACA;;AAEA,qBAAqB;AACrB,iFAAiF;AACjF,4BAA4B;AAC5B,4BAA4B;AAC5B,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,oCAAoC;;AAEpC,kEAAkE;AAClE,gCAAgC;AAChC,gCAAgC;AAChC;;AAEA,wBAAwB;AACxB;AACA;;AAEA,mBAAmB;AACnB,2DAA2D;AAC3D,6CAA6C;AAC7C,6CAA6C;AAC7C,qDAAqD;AACrD,cAAc,OAAO;AACrB,oDAAoD;AACpD;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,+BAA+B,UAAU,MAAM,SAAS;AACxD,sDAAsD,WAAW;AACjE,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA,yCAAyC;AACzC;AACA;;;AAGA,CAAC,+DAAW;AACZ;AACA,kBAAkB,iCAAiC,OAAO;AAC1D;AACA,IAAI;AACJ,GAAG;AACH;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;;;AC1D0B,CAAC;AAC/C;AAC8C,CAAC;;AAE/C,6CAA6C;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;AAGA,wCAAwC;;AAExC,wEAAwE;;AAExE,GAAG,4DAAQ;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG,iDAAS,0BAA0B;;AAEtC;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAU,YAAY;AAC1B,IAAI;AACJ;AACA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;;;AC1EpB;AACA;AACA;AACA;AACA,sCAAsC;AACtC,uDAAuD;AACvD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;;AAGA,+DAA+D;AAC/D;AACA,kEAAkE;AAClE,sDAAsD;;AAEtD;AACA;AACA;AACA,+EAA+E,wEAAwE;AACvJ,EAAE;;AAEF;AACA;AACA,8BAA8B;AAC9B;AACA,EAAE;;AAEF;AACA;AACA,8BAA8B;AAC9B;AACA,EAAE;;;AAGF;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,KAAK,EAAC;AACrB;AAC+B,CAAC;;;;;;;;;;;;;;;;ACtEhC;AACA,iBAAiB,qFAAqF;;AAEtG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,cAAc;AACxC,4BAA4B,WAAW;AACvC,GAAG;AACH;AACA;AACA;;;AAGA,sDAAsD;AACtD,qCAAqC;AACrC,4CAA4C;;AAE5C,0CAA0C;;;AAG1C,2BAA2B;AAC3B;AACA,EAAE;;;AAGF;AACA;AACA;AACA,kDAAkD;AAClD,2CAA2C;AAC3C;;AAEA;AACA;AACA,6BAA6B;AAC7B,8BAA8B,WAAW,GAAG;AAC5C,KAAK,OAAO;AACZ,sCAAsC;AACtC;AACA;;AAEA;AACA,mDAAmD;AACnD,mDAAmD;AACnD,6BAA6B;;AAE7B;AACA,iBAAiB,mBAAmB,OAAO;AAC3C,4CAA4C;AAC5C,4CAA4C;AAC5C,4BAA4B;AAC5B,gBAAgB;AAChB,0BAA0B;AAC1B;AACA,2BAA2B;AAC3B,kBAAkB;AAClB;;AAEA,iCAAiC;AACjC;AACA;;;AAGA;AACA,gEAAgE;AAChE,eAAe;AACf,IAAI,OAAO;AACX,qCAAqC;AACrC;AACA;AACA;AACA,GAAG;;AAEH,+CAA+C,OAAO,MAAM;;AAE5D,qCAAqC;AACrC,mBAAmB;AACnB,IAAI,OAAO;AACX,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA,qBAAqB;AACrB,0DAA0D;AAC1D,IAAI,OAAO;AACX,qCAAqC;AACrC;AACA;AACA;AACA,GAAG;;AAEH,+CAA+C,OAAO,MAAM;;AAE5D,yBAAyB;AACzB,+BAA+B;AAC/B,IAAI,OAAO;AACX,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF,uBAAuB;AACvB,yCAAyC;AACzC,2DAA2D;AAC3D;AACA,yBAAyB;AACzB,oDAAoD;AACpD;AACA,gDAAgD,OAAO,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;ACtJrB;AACA;;AAEA;AACA,uEAAuE;AACvE,0DAA0D;AAC1D,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,4CAA4C;AAC5C,SAAS;AACT;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA,iEAAe,IAAI;;;;;;;;;;;;;;;AC1CnB,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA,cAAc,IAAI;AAClB,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;AC1DpB;;AAEA;AACA,wCAAwC;AACxC,gCAAgC;AAChC;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,GAAG;;AAEL,0BAA0B;AAC1B;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,2CAA2C,IAAI,YAAY,WAAW,IAAI;AAC1E;;AAEA,6BAA6B;AAC7B;;AAEkB,CAAC;AACE;;;;;;;UC/BrB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,CAAmC,CAAC;AACpC,CAAqC,CAAC;AACtC,CAAqC;AACrC,CAAqC;AACrC,CAAuC;AACvC,CAAqC;AACrC,CAAmC;AACnC,CAA2C,CAAC;;AAE5C;AACA;AACA,wCAAwC,yDAAS,kCAAkC;;AAEnF,EAAE,yDAAI,oFAAoF;AAC1F,EAAE,0DAAK,0CAA0C;AACjD,EAAE,0DAAK,0BAA0B;AACjC,EAAE,0DAAK;AACP,EAAE,2DAAM,GAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,EAAE,0DAAK,wBAAwB;AAC/B,EAAE,yDAAI;AACN,CAAC;;AAED;AACA;AACA;;AAEA","sources":["webpack://food_dist/./js/modules/calc.js","webpack://food_dist/./js/modules/cards.js","webpack://food_dist/./js/modules/forms.js","webpack://food_dist/./js/modules/modal.js","webpack://food_dist/./js/modules/slider.js","webpack://food_dist/./js/modules/tabs.js","webpack://food_dist/./js/modules/timer.js","webpack://food_dist/./js/services/services.js","webpack://food_dist/webpack/bootstrap","webpack://food_dist/webpack/runtime/define property getters","webpack://food_dist/webpack/runtime/hasOwnProperty shorthand","webpack://food_dist/webpack/runtime/make namespace object","webpack://food_dist/./js/script.js"],"sourcesContent":["\n// Создаем фунцию и вставляем внутрь код из большого файла script.js\nfunction calc() {\n\n    // Calc\n\tconst result = document.querySelector('.calculating__result span'); \n\tlet sex, height, weight, age, ratio; \n\t\n\n\tif (localStorage.getItem('sex')) { \n\t\tsex = localStorage.getItem('sex'); \n\t} else { \n\t\tsex = 'female'; \n\t\tlocalStorage.setItem('sex', 'female'); \n\t}\n\t\n\tif (localStorage.getItem('ratio')) { \n\t\tratio = localStorage.getItem('ratio'); \n\t} else { \n\t\tratio = 1.375; \n\t\tlocalStorage.setItem('ratio', 1.375); \n\t}\n\t\n\t\n\tfunction initLocalSettings(selector, activeClass) { \n\t\tconst elements = document.querySelectorAll(selector); \n\t\n\t\telements.forEach(elem => { \n\t\t\telem.classList.remove(activeClass); \n\t\t\tif (elem.getAttribute('id') === localStorage.getItem('sex')) { \n\t\t\t\telem.classList.add(activeClass); \n\t\t\t}\n\t\t\tif (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) { \n\t\t\t\telem.classList.add(activeClass); \n\t\t\t}\n\t\t});\n\t}\n\tinitLocalSettings('#gender div', 'calculating__choose-item_active'); \n\tinitLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active'); \n\t\n\t\n\tfunction calcTotal() { \n\t\tif (!sex || !height || !weight || !age || !ratio) { \n\t\t\tresult.textContent = '...'; \n\t\t\treturn; \n\t\t} \n\t\n\t\tif (sex === 'female') { \n\t\t\tresult.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio); \n\t\t} else { \n\t\t\tresult.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio); \n\t\t}\n\t}\n\tcalcTotal(); \n\t\n\t\n\tfunction getStaticInfo(selector, activeClass) { \n\t\tconst elements = document.querySelectorAll(selector); \n\t\n\t\telements.forEach(elem => {  \n\t\t\telem.addEventListener('click', (e) => { \n\t\t\t\tif (e.target.getAttribute('data-ratio')) { \n\t\t\t\t\tratio = +e.target.getAttribute('data-ratio'); \n\t\t\t\t\tlocalStorage.setItem('ratio', +e.target.getAttribute('data-ratio')); \n\t\t\t\t} else { \n\t\t\t\t\tsex = e.target.getAttribute('id'); \n\t\t\t\t\tlocalStorage.setItem('sex', e.target.getAttribute('id')); \n\t\t\t\t}\n\t\t\t\tconsole.log(ratio, sex);\n\t\n\t\t\t\telements.forEach(elem => { \n\t\t\t\t\telem.classList.remove(activeClass); \n\t\t\t\t});\n\t\t\t\te.target.classList.add(activeClass); \n\t\t\t\tcalcTotal(); \n\t\t\t});\n\t\t});\n\t}\n\t\n\tgetStaticInfo('#gender div', 'calculating__choose-item_active'); \n\tgetStaticInfo('.calculating__choose_big div', 'calculating__choose-item_active'); \n\t\n\t\n\tfunction getDynamicInfo(selector) { \n\t\tconst input = document.querySelector(selector); \n\t\n\t\tinput.addEventListener('input', () => { \n\t\n\t\t\tif (input.value.match(/\\D/g)) { \n\t\t\t\tinput.style.border = '1px solid red'; \n\t\t\t} else { \n\t\t\t\tinput.style.border = 'none'; \n\t\t\t}\n\t\n\t\t\tswitch(input.getAttribute('id')) { \n\t\t\t\tcase 'height': \n\t\t\t\t\theight = +input.value; \n\t\t\t\t\tbreak; \n\t\t\t\tcase 'weight': \n\t\t\t\t\tweight = +input.value; \n\t\t\t\t\tbreak;\n\t\t\t\tcase 'age': \n\t\t\t\t\tage = +input.value; \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcalcTotal(); \n\t\t});\n\t}\n\t\n\tgetDynamicInfo('#height');\n\tgetDynamicInfo('#weight');\n\tgetDynamicInfo('#age');\n}\n\nexport default calc; // Модифицируем экспорт на Модульную структуру ES6 (вместо CommandJS) - было module.exports = calc;","\nimport {getResource} from '../services/services'; // импортируем функцию, которая работает с севрвером\n\nfunction cards() {\n\t// Use class for card\n\n    class MenuCard { // Создание шаблона\n        constructor(src, alt, title, descr, price, parentSelector, ...classes) { // classes (rest оператор - если мы не знаем, какие мы классы в будущем захотим добавить этому элементу)\n            this.src = src; // путь для картинки\n            this.alt = alt; // альтернативный текст (будет подгружаться, если картинка сломалась)\n            this.title = title; // заголовок\n            this.descr = descr; // описание \n            this.price = price; // цена\n            this.classes = classes; // rest оператор (внутри будет массив)\n\n            this.parent = document.querySelector(parentSelector); // Родитель элемента\n            this.transfer = 88; // Курс рубля к гривне\n            this.changeToUAH(); // вставляем метод после this.price и this.transfer (свойства в классе тоже идут по порядку сверху вниз)\n        }\n\n        changeToUAH() { // Добавялем метод (конвертация валюты)\n            this.price = this.price * this.transfer;\n        }\n\n        render() { // Создание нового элемента (помещаем в него верстку, ее дополняем данными, которые приходят, как аргументы и помещаем элемент на страницу)\n            const element = document.createElement('div'); // создание нового элемента с классом div\n            if (this.classes.length === 0) { // ставим параметры по умолчанию через условие (если массив rest оператора будет пустым)\n                this.element = 'menu__item'; // записали в свойство класса значение (это не связано с переменной element) PS: если мы создаем свойство внутри метода - это не считается конструктором. Просто свойство появилось в процессе работы класса.\n                element.classList.add(this.element); // добавляем в element значение this.element\n            } else { // Если в массиве rest есть какие нибудь элементы, то добавляем их\n                this.classes.forEach(className => { // с помощью перебора добавляем элементу классы\n                    element.classList.add(className);\n                });\n            }\n\n        \n            element.innerHTML = ` \n                    <img src=${this.src} alt=${this.alt}> \n                    <h3 class=\"menu__item-subtitle\">${this.title}</h3>\n                    <div class=\"menu__item-descr\">${this.descr}</div>\n                    <div class=\"menu__item-divider\"></div>\n                    <div class=\"menu__item-price\">\n                        <div class=\"menu__item-cost\">Цена:</div>\n                        <div class=\"menu__item-total\"><span>${this.price}</span> рублей/день</div>\n                    </div>\n            `;\n            this.parent.append(element); // вставляем элемент внутрь родителя\n        }\n    }\n\n\n\tgetResource('http://localhost:3000/menu')\n\t\t.then(data => {\n\t\t\tdata.forEach(({img, altimg, title, descr, price}) => { // дестркутуризация\n\t\t\t\tnew MenuCard(img, altimg, title, descr, price, '.menu .container').render();\n\t\t\t});\n\t\t});\n}\n\nexport default cards;","\nimport {closeModal, openModal} from './modal'; // импортируем функции openModal, closeModal в модуль forms - импортиурем синтаксисом именованных импортов\n// Импорт функции, которая работает с сервером\nimport {postData} from '../services/services'; // импортируем функциию постинга данных из services.js\n\nfunction forms(formSelector, modalTimerId) { // добавляем аргумент\n\n\tconst forms = document.querySelectorAll(formSelector);\n\n\tconst message = {\n\t\tloading: 'Загрузка',\n\t\tsuccess: 'Спасибо, скоро мы с вами свяжемся',\n\t\tfailure: 'Что-то пошло не так...'\n\t};\n\n\tforms.forEach(item => {\n\t\tbindPostData(item);\n\t});\n\n\n\tfunction bindPostData(form) { // меняем название функции на привязку постинга данных\n\t\tform.addEventListener('submit', (e) => {\n\t\t\te.preventDefault();\n\t\t\tconst statusMessage = document.createElement('div');\n\t\t\tstatusMessage.classList.add('status');\n\t\t\tstatusMessage.innerHTML = message.loading;\n\t\t\tform.append(statusMessage);\n\n\n\t\t\tconst formData = new FormData(form); // у формы в input всегда должен быть атрибут 'name' (иначе FormData не сможет найти input и не сможет взять у него value для того, чтобы сформировать правильно обьект)\n\n\t\t\tconst json = JSON.stringify(Object.fromEntries(formData.entries())); // другой способ преобразования formData в json (formData.entries() - получаем массив пар ключ: значение, Object.fromEntries() - преобразовываем из массива обратно в обьект, JSON.stringify - преобразовываем его в json формат)\n\n\t\t\tpostData(' http://localhost:3000/requests', json) // используем эту функцию вместо fetch выше, данные будут отправляться в db.json   (в качестве data был JSON.stringify(object))\n\t\t\t\t// .then(data => data.text()) // это убираем потому что в функции postData трансофрмация текста происходит автоматически и она там спрятана внутри\n\t\t\t\t.then((data) => {\n\t\t\t\t\tconsole.log(data);\n\t\t\t\t\tshowThanksModal(message.success);\n\t\t\t\t\tstatusMessage.remove();\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tshowThanksModal(message.failure);\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tform.reset();\n\t\t\t\t});\t\t\t\t\t\n\t\t});\n\n\t// Красивое оповещение\n\t\tfunction showThanksModal(message) {\n\t\t\tconst previousModalDialog = document.querySelector('.modal__dialog');\n\n\t\t\tpreviousModalDialog.classList.add('hide');\n\t\t\topenModal('.modal', modalTimerId); // передаем аргументы \n\n\t\t\tconst thanksModal = document.createElement('div');\n\t\t\tthanksModal.classList.add('modal__dialog');\n\t\t\tthanksModal.innerHTML = `\n\t\t\t\t<div class=\"modal__content\">\n\t\t\t\t\t<div class=\"modal__close\" data-close>×</div>\n\t\t\t\t\t<div class=\"modal__title\">${message}</div>\n\t\t\t\t</div>\n\t\t\t`;\n\n\t\t\tdocument.querySelector('.modal').append(thanksModal);\n\t\t\tsetTimeout(() => {\n\t\t\t\tthanksModal.remove();\n\t\t\t\tpreviousModalDialog.classList.add('show');\n\t\t\t\tpreviousModalDialog.classList.remove('hide');\n\t\t\t\tcloseModal('.modal'); // передаем селектор (аргумент из modal)\n\t\t\t}, 3000);\n\t\t}\n\t}\n}\n\nexport default forms;","\n// функции openModal и closeModal делаем отдельной функциональности - вырезаем из функции modal и помещаем над ней (в самый верх модуля)\n// т.к переменная modal накондится внутри функции modal, при вызове closeModal - работа с modal выдаст ошибку (потому что переменной modal не существует внутри функции closeModal)\n// каждый модуль должен быть независим друг от друга - нельзя вызывать в одном модуле кусочек другого модуля, они не должна привязываться к одним и тем же сущностям (как с переменной modal)\n// нужно создавать модули так, чтобы они зависели только от аргументов, которые в них передаются - потому что каждый модуль может быть вызван несколько раз для разных элементов\n\tfunction closeModal(modalSelector) { // передаем аргумент, потом этот аргумент будем использовать в функции modal (как бы связываем их с помощью аргументов) - название аргмумента этого не имеет значения\n\t\tconst modal = document.querySelector(modalSelector); // создаем переменную для получение элемента через аргумент\n\t\tmodal.classList.add('hide');\n\t\tmodal.classList.remove('show');\n\t\tdocument.body.style.overflow = '';\n\t}\n\n\n\t// Настраиваиваем modalTimerId: (ключевое правило: понимать что за чем идет, куда что необходимо передавать, где что нужно расположить и идти по своему алгоритму, то сложностей не будет)\n\t// 1. Передаем его в качестве аргумента в функцию openModal - потому что нам необходимо работать через аргументы, а не через сущности (переменные) - не универсально\n\t// 2. Добавляем его в качестве аргумента в функцию modal (для связи openModal и modal)\n\t// 3. переносим переменную modalTimerId глобально в script.js (потому что она будет юзатся и в modal и в forms)\n\t\t// 3.1 Импортируем в script.js функцию openModal для использования modalTimerId глобально\n\t// 4. Передаем в forms в аргумент формы modalTimerId (для связи openModal и forms) и в модуле forms подставляем аргументы для функций openModal и closeModal\n\t// 5. Подставляем все аргументы в вызове функций в script.js\n\n\tfunction openModal(modalSelector, modalTimerId) { // аналогично передаем аргумент\n\t\tconst modal = document.querySelector(modalSelector); // создаем переменную для получение элемента через аргумент\n\t\tmodal.classList.add('show');\n\t\tmodal.classList.remove('hide');\n\t\tdocument.body.style.overflow = 'hidden';\n\n\t\tconsole.log(modalTimerId);\n\t\t// Условие (если modalTimerId существует)\n\t\tif (modalTimerId) {\n\t\t\tclearInterval(modalTimerId); // то запускаем очистку таймера (будет очищаться таймер, который находится в переменной modalTimerId, которая в script.js)\n\t\t}\n\t}\n\n\nfunction modal(triggerSelector, modalSelector, modalTimerId) { // передаем три аргумента\n    // Modal\n\tconst modalTrigger = document.querySelectorAll(triggerSelector); //  было document.querySelectorAll('[data-modal]');\n\tconst modal = document.querySelector(modalSelector); // было document.querySelectorAll('.modal');\n\n\t// когда в обработичке событий передаем callback функцию, мы не должны ее сразу вызывать (мы должны ее обьявить) - ('click', openModal);\n\t// !!! NEW INFO: Для того чтобы обойти это ограничение создаем стрелочную функцию, которая оборачивает нашу вызывающуяся функцию - ('click', () => openModal())\n\tmodalTrigger.forEach(btn => {\n\t\tbtn.addEventListener('click', () => openModal(modalSelector, modalTimerId)); // передаем аргументы в фунциюю openModal, было - ('click', openModal); modalTimerId добавляем дял связи с openModal\n\t});\n\n\tmodal.addEventListener('click', (e) => { \n\t\tif (e.target === modal || e.target.getAttribute('data-close') == '') { \n\t\t\tcloseModal(modalSelector); // подставляем аргумент\n\t\t}\n\t});\n\n\tdocument.addEventListener('keydown', (e) => {\n\t\tif (e.code === 'Escape' && modal.classList.contains('show')) {\n\t\t\tcloseModal(modalSelector); // подставляем аргумент\n\t\t}\n\t});\n\n\n\tfunction showModalByScroll() {\n\t\tif (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight -1) {\n\t\t\topenModal(modalSelector, modalTimerId); // подставляем аргументы\n\t\t\twindow.removeEventListener('scroll', showModalByScroll);\n\t\t}\n\t}\n\n\twindow.addEventListener('scroll', showModalByScroll);\n}\n\nexport default modal;\n// в модуле forms (нет фукнций openModal и closeModal)\nexport {closeModal, openModal}; // экспортируем функции (отдельные от modal) - делаем их именованными, а не по умолчанию\n","\n// Деструктуризируем - меняем селекторы на аргументы функции slider с помощью обьекта\nfunction slider({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) {\n\n    // Slider \n\tconst slides = document.querySelectorAll(slide), // Подставляем аргумент slide (при вызове в script.js будет вызваться значение ключа slide - '.offer__slide'\n\t\tprev = document.querySelector(prevArrow), \n\t\tnext = document.querySelector(nextArrow), \n\n\t\ttotal = document.querySelector(totalCounter), \n\t\tcurrent = document.querySelector(currentCounter), \n\t\tslidesWrapper = document.querySelector(wrapper), \n\t\tslidesField = document.querySelector(field), \n\t\twidth = window.getComputedStyle(slidesWrapper).width; \n\n\tconst slider = document.querySelector(container); // Подставляем аргумент container (при вызове в script.js будет вызваться значение ключа container - '.offer__slider'\n\tslider.style.position = 'relative'; \n\tconst dots = []; \n\n\tlet slideIndex = 1; \n\tlet offset = 0; \n\n\tif (slides.length < 10) { \n\t\ttotal.textContent = `0${slides.length}`; \n\t\tcurrent.textContent = `0${slideIndex}`; \n\t} else {\n\t\ttotal.textContent = slides.length; \n\t\tcurrent.textContent = slideIndex; \n\t}\n\n\n\tslidesField.style.width = 100 * slides.length + '%'; // меняем ширину карусели (100 * количество слайдов) - 400%\n\tslidesField.style.display = 'flex'; // Карусель делаем в флексбокс (чтобы слайды стали горизонтально)\n\tslidesField.style.transition = '0.5s all'; // добавляем карусели плавный переход \n\n\tslidesWrapper.style.overflow = 'hidden'; // Все выходит за пределы обертки делаем невидимым\n\n\n\tslides.forEach(slide => { // слайдам делаем фиксированную ширину в 650px (если этого не делать и без флексбокса и хиддена, ширина будет занимать все ширинку карусели - 2600px)\n\t\tslide.style.width = width;\n\t});\n\n\n\t// Выводим повторяющийся функционал в отдельные функции\n\t\t// Функция добавления класса активности точкам (работа с массивом)\n\t\tfunction dotActive() {\n\t\t\tdots.forEach(dot => dot.style.opacity = '.5'); // перебираем массив и меняем прозрачность всем точкам на 0.5\n\t\t\tdots[slideIndex - 1].style.opacity = 1; // Первой точке и последующим при клике (будет менять прозрачность на 1 - на активную точку)\n\t\t}\n\n\t\t// Функция добавления текущего слайда на страницу\n\t\tfunction currentOnPage() {\n\t\t\tif (slides.length < 10) { // если количество слайдов меньше 10\n\t\t\t\tcurrent.textContent = `0${slideIndex}`; // То вставляем на страницу с 0\n\t\t\t} else { // если меньше 10 \n\t\t\t\tcurrent.textContent = slideIndex; // То вставялем на сраницу без 0\n\t\t\t}\n\t\t}\n\n\t// Создаем обертку для наших точек\n\tconst dotsWrapper = document.createElement('ol'); // создаем обертку - элемент ordered-list\n\tdotsWrapper.classList.add('carousel-indicators'); // добавляем ему класс\n\tslider.append(dotsWrapper); // помещаем его внутрь слайдера\n\n\t// Создаем новые элементы (точки) с помощью цикла\n\tfor (let i = 0; i < slides.length; i++) { // цикл (i меньше количества слайдов)\n\t\tconst dot = document.createElement('li'); // создаем точки (list-item)\n\t\tdot.setAttribute('data-slide-to', i + 1); // устанавливаем data атрибут точкам со значением i + 1 (0 + 1) - чтобы потом его сопоставить с текущим слайдом на странице\n\t\tdot.classList.add('dot'); // устанавливаем класс для точек\n\t\tif (i == 0) { // условие (если i == 0 - первая точка)\n\t\t\tdot.style.opacity = 1; // меняем класс прозрачности (делаем первый элемент активным)\n\t\t}\n\t\tdotsWrapper.append(dot); // устанавливаем точки внутрь нашего списка\n\t\tdots.push(dot); // пушим в массив наши точки\n\t}\n\n\tfunction deleteNotDigits(str) { // добавляем функцию (удаляем не числа с помощью регулярки)\n\t\treturn +str.replace(/\\D/g, '');\n\t}\n\n\n\tnext.addEventListener('click', (e) => {\n\t\tif (offset == deleteNotDigits(width) * (slides.length - 1)) { // Условие (если ширина (переводим в number и отрезаем пиксели) умноженная на количество слайдов - 1 (это последний слайд в массиве слайдов, именно его номер - получается, что первый слайд идет в ширину 650px и когда смещаемся на 1950px, при следующем клике сработает наше условие) - \"мы долистали до конца слайдера и пора вернуть его к первому слайду\"\n\t\t\toffset = 0; // тогда возвращаем карусель заново\n\t\t} else { // Если не поледний слайд\n\t\t\toffset += deleteNotDigits(width); // Добавляем offset (смещение) ширину без пикселей\n\t\t}\n\t\tslides.forEach(item => {\n\t\t\titem.classList.remove('hide');\n\t\t});\n\n\t\tslidesField.style.transform = `translateX(-${offset}px)`; // перемещаем карусель (вправо это будет -X (-650px)) - ориентируемся по оси Х (влево минус, вправо плюс)\n\n\t\tif (slideIndex == slides.length) { // если текущий слайд будет равен последнему слайду\n\t\t\tslideIndex = 1; // то переместимся на первый слайд\n\t\t} else { // если не дошел до конца слайдера (не последий слайд)\n\t\t\tslideIndex++; // то прибавляем slideIndex на 1\n\t\t}\n\n\t\t// Добавляем текущий слайд на страницу\n\t\tcurrentOnPage();\n\n\t\t// Добавление активности точкам в зависимости от кнопки на которую нажали\n\t\tdotActive();\n\t});\n\n\n\tprev.addEventListener('click', () => {\n\t\tif (offset == 0) { // Условие (если offset будет равен 0, то при клике на кнопку предыдущего слайдера будет срабатывать условие)\n\t\t\toffset = deleteNotDigits(width) * (slides.length - 1); // тогда возвращаем слайдер в последний слайд (offset 1950px - cмещение на 1950px - на последний слайд)\n\t\t} else { // Если не первый слайд\n\t\t\toffset -= deleteNotDigits(width); // у offset (смещения) отнимаем ширину (- на - будет давать +)\n\t\t}\n\t\tslides.forEach(item => {\n\t\t\titem.classList.remove('hide');\n\t\t});\n\n\t\tslidesField.style.transform = `translateX(-${offset}px)`; // Перемещаем карусель (Влево это будет - (-650px) - минус на минус плюс = +650px) \n\n\t\tif (slideIndex == 1) { // если у нас первый слайд\n\t\t\tslideIndex = slides.length; // То меняем slideIndex на количетсво всех слайдов (то есть перемещаемся в конец слайдера)\n\t\t} else { // Если не первый слайд\n\t\t\tslideIndex--; // То мы уменьшаем наш slideIndex на 1\n\t\t}\n\n\t\t// Добавляем текущий слайд на страницу\n\t\tcurrentOnPage();\n\n\t\t// Добавление активности точкам в зависимости от кнопки на которую нажали\n\t\tdotActive();\n\n\t});\n\n\tdots.forEach(dot => { // перебираем массив\n\t\tdot.addEventListener('click', (e) => { // вешаем обработчик событий на отдельную точку\n\t\t\tconst slideTo = e.target.getAttribute('data-slide-to'); // помещаем в переменную (наше значение data-slide-to)\n\t\n\t\t\tslideIndex = slideTo; // меняем наш slideIndex на значение в data атрибуте (кликнули на 4 точку и в slideIndex пойдет значение 4)\n\t\t\toffset = deleteNotDigits(width) * (slideTo - 1); // получение offset (ширину умножаем на slideTo - 1) - смещение на определенную ширину (нажали на 3 кнопку - ширину 650 * 2 = 1300px, на 4 кнопку - 650 * 3 = 1950px) \n\t\n\t\t\tslidesField.style.transform = `translateX(-${offset}px)`; // добавляем смещение слайдера \n\t\n\t\t\t// Добавляем текущий слайд на страницу\n\t\t\tcurrentOnPage();\n\t\n\t\t\t// Добавление активности точкам в зависимости от кнопки на которую нажали\n\t\t\tdotActive();\n\t\t});\n\t});\n}\n\nexport default slider;","\n// Меняем селекторы на аргмуенты функции (после этого мы можем вызывать несколько табов на странице, делаем универсальным модуль (наш модуль не знает с какими элементами он будет работать до вызова, ему это и не нужно знать))\nfunction tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\n\n    // Tabs\n    const tabContent = document.querySelectorAll(tabsContentSelector); // Подставляем аргумент\n    const tabs = document.querySelectorAll(tabsSelector); // Подставляем аргумент\n    const tabsParent = document.querySelector(tabsParentSelector); // Подставляем аргумент\n\n    const hideTabContent = () => {\n        tabContent.forEach(item => {\n        item.classList.add('hide');\n        item.classList.remove('show', 'fade');\n        });\n\n        tabs.forEach(item => {\n        item.classList.remove(activeClass); // Подставляем аргумент\n        });\n    };\n\n    const showTabContent = (i = 0) => { \n        tabContent[i].classList.add('show', 'fade');\n        tabContent[i].classList.remove('hide');\n        tabs[i].classList.add(activeClass); // Подставляем аргумент\n    };\n\n    hideTabContent();\n    showTabContent();\n\n    tabsParent.addEventListener('click', (e) => {\n        const target = e.target;\n        // Подставляем аргумент ('.tabheader__item'), но у нас classList - селектор должен быть без точки\n        if (target && target.classList.contains(tabsSelector.slice(1))) { // чтобы не было ошибки (начинаем аргмуент со второго символа - без точки)\n        tabs.forEach((item, i) => {\n            if (target == item) { \n            hideTabContent(); \n            showTabContent(i); \n            }\n        });\n        }\n    });\n}\n\nexport default tabs;","\nfunction timer(id, deadline) { // Добавляем аргументы функции (deadline ставим, чтобы менять даты в script.js - для удобства)\n\n    // Timer\n\tfunction getTimeRemaining(endtime) {\n\t\tlet days, hours, minutes, seconds;\n\t\tconst t = Date.parse(endtime) - Date.now();\n\t\tif (t <= 0) {\n\t\t\tdays = 0;\n\t\t\thours = 0;\n\t\t\tminutes = 0;\n\t\t\tseconds = 0;\n\t\t} else {\n\t\t\tdays = Math.floor(t / (1000 * 60 * 60 * 24));\n\t\t\thours = Math.floor((t / (1000 * 60 * 60) % 24));\n\t\t\tminutes = Math.floor((t / (1000 * 60) % 60));\n\t\t\tseconds = Math.floor((t / 1000) % 60);\n\t\t}\n\n\t\treturn {total: t, days, hours, minutes, seconds};\n\t}\n\n\tfunction getZero(num) {\n\t\tif (num >= 0 && num < 10) {\n\t\t\treturn `0${num}`;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t} \n\n\tfunction setClock(selector, endtime) {\n\t\tconst timer = document.querySelector(selector),\n\t\t\tdays = timer.querySelector('#days'),\n\t\t\thours = timer.querySelector('#hours'),\n\t\t\tminutes = timer.querySelector('#minutes'),\n\t\t\tseconds = timer.querySelector('#seconds'),\n\n\t\t\ttimeInterval = setInterval(updateClock, 1000);\n\n\t\tupdateClock();\n  \n\t\tfunction updateClock() {\n\t\t\tconst t = getTimeRemaining(endtime);\n\t\t\t\tdays.innerHTML = getZero(t.days);\n\t\t\t\thours.innerHTML = getZero(t.hours);\n\t\t\t\tminutes.innerHTML = getZero(t.minutes);\n\t\t\t\tseconds.innerHTML = getZero(t.seconds);\n\t\t\t\n\t\t\t\tif (t.total <= 0) {\n\t\t\t\t\tclearInterval(timeInterval);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\n\tsetClock(id, deadline); // подставляем аргумент id\n\n}\n\nexport default timer;","// Функции, которые работают с сервером выносят с отдельный функцоинал (потому что на проекте она может пригодитсья где угодно)\n\n// Функция постинг данных из модуля forms\nconst postData = async (url, data) => { // создаем функцию постинг данных (url передается в fetch, data - данные, которые будут поститься)\n\tconst res = await fetch(url, { // переменная res внутрь помещаем промис, который возвращается от fetch, передаем аргумент url\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-type': 'application/json'\n\t\t},\n\t\tbody: data // было JSON.stringify(object)\n\t}); // res - это ответ от сервера (промис)\n\n\treturn await res.json(); // трансофрмируем ответ в json (возвращаем промис и дальше по обрабатываем по цепочке then), await ставим потому что нам нужно дождаться промис\n};\n\n// Функуция получения карточек\nconst getResource = async (url) => { // создаем функцию получение данных\n    const res = await fetch(url);\n\n    // Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой\n    // обрабатываем ошбику вручную \n    if (!res.ok) { // .ok ( логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299)\n        // Обьект ошибки new Error(текст ошибки)\n        // throw — это значение исключения, то есть описание ситуации, которая должна считать ошибочной. (выкинь нам ошибку)\n        throw new Error(`Could not fetch ${url}, status: ${res.status}`); // status – код статуса HTTP-запроса, например 200\n    }\n\n    return await res.json(); // трансофрмируем ответ в json (возвращаем промис и дальше по обрабатываем по цепочке then), await ставим потому что нам нужно дождаться промис\n};\n\nexport {postData}; // экспортируем функцию\nexport {getResource};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\n\n// Собираем модули в проекте - большой script.js разбиваем на маленькие кусочки (tabs, slider, timer и т.д) \n// Создаем папку modules в папке js и создаем там файлики tabs.js, calc.js  и т.д\n// Код из большого script.js вырезаем и вставляем в отдельные файлы - там создаем функции и внутрь вставляем код\n\n\t// Настраиваем импорты по Модульной структуре ES6 - рефакторим код (был CommandJS - const tabs = require('./modules/tabs'))\n\t// ESLint говорит, что нужно Все импорты поместить до DOMContentLoaded (в отличие от CommandJS) - импорты должны быть в самом верху\n\n\t// Настройка модулей: (фикс багов)\n\t// 1. Решение бага модуля forms(openModal и closeModal) // подробно написано в модуле modal.js и немного в forms.js\n\t// \t1.1 Делаем функции openModal и closeModal отдельной функциональности (вырезаем, экспортим и потом импортим куда надо) и создаем работу через аргументы, а не через зависимые сущности (переменные)\n\t// \t1.2 Чиним работу modalTimerId // подробно написано в модуле modal.js\n\t// 2. Фикс остальных модулей\n\t// \t2.1 Доработка модуля forms\n\t// \t\t2.1.1 Селектор form выносим как аргумент в функцию forms\n\t// \t\t2.1.2 Функцию postData (которая работает с сервером) выносим в сервисы - в отдельную папку и файл services.js, экспортим и импортируем в модуль forms\n\t//  2.3 Доработка модуля cards \n\t// \t\t2.3.1 Функцию getResource (серверная) вырезаем в сервисы, эксопртируем и импортируем в модуль cards\n\t//  2.4 Доработка модуля tabs\n\t// \t\t2.4.1 Меняем селекторы на аргументы функции tabs\n\t//  2.5 Доработка модуля timer\n\t// \t\t2.5.1 Меняем селектор на аргмуент функции timer ('.timer' на id)\n\t// \t\t2.5.2 Меняем переменную deadline на аргумент функции timer (для того, чтобы не лезть в модуль и там менять дату, для удобства и быстроты изменять ее через аргмуент в script.js)\n\t//  2.6 Калькулятор calc - не трогаем, они редко похожи друг на друга и переиспользовать его еще раз это очень редкий сценарий (но если нужно,то  всегда можно его переписать как модули выше)\n\t// 2.7 Доработка модуля slider\n\t\t// 2.7.1 Использование деструктуризации для передачи аргументов (порядок свойств не будет влиять)\n\t\t\t// 2.7.1.1 Создаем обьект внутри обьявления slider() в модуле slider и передаем аргументы, которые заменят селекторы и меняем селекторы на аргументы\n\t\t\t// 2.7.1.2 Создаем обьект внутри вызова slider() и подставляем аргументы в виде свойств обьекта: ключ - аргумент, значение - селектор\n\t\t\t// 2.7.1.3 При вызове slider() будут подстраиваться значения ключей - селекторы (все отработает, как надо)\n\n\n\timport tabs from './modules/tabs'; // Импортируем функцию из файла tabs.js - юзаем CommandJS,  PS: порядок подключения модулей не важен\n\timport modal from './modules/modal'; // Импортируем функцию из файла modal.js - юзаем CommandJS\n\timport timer from './modules/timer';\n\timport cards from './modules/cards';\n\timport slider from './modules/slider';\n\timport forms from './modules/forms';\n\timport calc from './modules/calc';\n\timport {openModal} from './modules/modal'; // импортируем openModal, потому что мы юзаем ее в script.js (в modalTimerId глобально)\n\nwindow.addEventListener('DOMContentLoaded', () => {\n\t\t// Создаем переменную в script.js (потому что этот аргумент будет юзаться и в модуле modal и в forms (в функциях openModal, которые внутри этих модулей))\n\t\tconst modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 50000); // делаем стрелочную функцию, чтобы передать аргументы\n\n\t\ttabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active'); // вызываем функцию tabs и подставляем все аргументы\n\t\tmodal('[data-modal]', '.modal', modalTimerId); // вызываем функцию modal и подставляем аргументы - тут мы связываем openModal и modal и в дальнейшем forms (в этом модуле есть openModal)\n\t\ttimer('.timer', '2024-07-16'); // передаем аргументы - селектор и дату деадлайна\n\t\tcards();\n\t\tslider({ // использование деструктуризации (передаем обьект, который будет содержать определные настройки)\n\t\t\tcontainer: '.offer__slider', // в клюич container (аргмуент функции slider) подставляем значение селектора\n\t\t\tnextArrow: '.offer__slider-next',\n\t\t\tprevArrow: '.offer__slider-prev',\n\t\t\tslide: '.offer__slide',\n\t\t\ttotalCounter: '#total',\n\t\t\tcurrentCounter: '#current',\n\t\t\twrapper: '.offer__slider-wrapper',\n\t\t\tfield: '.offer__slider-inner',\n\n\t\t});\n\t\tforms('form', modalTimerId); // передаем аргумент в формы, потому что будем юзать его в формах для функции openModal\n\t\tcalc();\n});\n\n// npx webpack (собираем все вместе)\n// в папке js появился файл bundle.js\n// в HTML подключить файл bundle.js - <script src=\"js/bundle.js\"></script>\n\n// lifehack: чтобы юзать два терминала одновременно (webpack и json-server) использовать кнопку + в терминале (создание нового терминала)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"names":[],"sourceRoot":""}